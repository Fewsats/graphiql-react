{"version":3,"file":"static/js/878.0416e321.chunk.js","mappings":"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","sources":["../node_modules/@graphiql/graphql-language-service/esm/utils/Range.js","../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../node_modules/graphql/language/predicates.mjs","../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../node_modules/graphql/jsutils/groupBy.mjs","../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../node_modules/graphql/utilities/sortValueNode.mjs","../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../node_modules/graphql/execution/values.mjs","../node_modules/graphql/execution/collectFields.mjs","../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../node_modules/graphql/validation/specifiedRules.mjs","../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs","../node_modules/graphql/validation/ValidationContext.mjs","../node_modules/graphql/validation/validate.mjs","../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../node_modules/@graphiql/graphql-language-service/esm/utils/validateWithCustomRules.js","../node_modules/@graphiql/graphql-language-service/esm/interface/getDiagnostics.js","../node_modules/@graphiql/codemirror-graphql/esm/lint.js"],"sourcesContent":["export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            return this.start.line <= position.line && this.end.line >= position.line;\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n","/**\n * Groups array items into a Map, given a function to produce grouping key.\n */\nexport function groupBy(list, keyFn) {\n  const result = new Map();\n\n  for (const item of list) {\n    const key = keyFn(item);\n    const group = result.get(key);\n\n    if (group === undefined) {\n      result.set(key, [item]);\n    } else {\n      group.push(item);\n    }\n  }\n\n  return result;\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n","import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n","import { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Sort ValueNode.\n *\n * This function returns a sorted copy of the given ValueNode.\n *\n * @internal\n */\n\nexport function sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return { ...valueNode, fields: sortFields(valueNode.fields) };\n\n    case Kind.LIST:\n      return { ...valueNode, values: valueNode.values.map(sortValueNode) };\n\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\n\nfunction sortFields(fields) {\n  return fields\n    .map((fieldNode) => ({\n      ...fieldNode,\n      value: sortValueNode(fieldNode.value),\n    }))\n    .sort((fieldA, fieldB) =>\n      naturalCompare(fieldA.name.value, fieldB.name.value),\n    );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (!sameArguments(node1, node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(node1, node2) {\n  const args1 = node1.arguments;\n  const args2 = node2.arguments;\n\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n  /* c8 ignore next */\n\n  if (args1.length !== args2.length) {\n    /* c8 ignore next */\n    return false;\n    /* c8 ignore next */\n  }\n\n  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));\n  return args1.every((arg1) => {\n    const value1 = arg1.value;\n    const value2 = values2.get(arg1.name.value);\n\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction stringifyValue(value) {\n  return print(sortValueNode(value));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isInputType, isNonNullType } from '../type/definition.mjs';\nimport { coerceInputValue } from '../utilities/coerceInputValue.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { valueFromAST } from '../utilities/valueFromAST.mjs';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = print(varDefNode.type);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  let variableDefinitions = {};\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefinitions = {};\n      },\n    },\n\n    VariableDefinition(definition) {\n      variableDefinitions[definition.variable.name.value] = definition;\n    },\n\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n\n      if (type.isOneOf) {\n        validateOneOfInputObject(\n          context,\n          node,\n          type,\n          fieldNodeMap,\n          variableDefinitions,\n        );\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n\nfunction validateOneOfInputObject(\n  context,\n  node,\n  type,\n  fieldNodeMap,\n  variableDefinitions,\n) {\n  var _fieldNodeMap$keys$;\n\n  const keys = Object.keys(fieldNodeMap);\n  const isNotExactlyOneField = keys.length !== 1;\n\n  if (isNotExactlyOneField) {\n    context.reportError(\n      new GraphQLError(\n        `OneOf Input Object \"${type.name}\" must specify exactly one key.`,\n        {\n          nodes: [node],\n        },\n      ),\n    );\n    return;\n  }\n\n  const value =\n    (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null ||\n    _fieldNodeMap$keys$ === void 0\n      ? void 0\n      : _fieldNodeMap$keys$.value;\n  const isNullLiteral = !value || value.kind === Kind.NULL;\n  const isVariable =\n    (value === null || value === void 0 ? void 0 : value.kind) ===\n    Kind.VARIABLE;\n\n  if (isNullLiteral) {\n    context.reportError(\n      new GraphQLError(`Field \"${type.name}.${keys[0]}\" must be non-null.`, {\n        nodes: [node],\n      }),\n    );\n    return;\n  }\n\n  if (isVariable) {\n    const variableName = value.name.value;\n    const definition = variableDefinitions[variableName];\n    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;\n\n    if (isNullableVariable) {\n      context.reportError(\n        new GraphQLError(\n          `Variable \"${variableName}\" must be non-nullable to be used for OneOf Input Object \"${type.name}\".`,\n          {\n            nodes: [node],\n          },\n        ),\n      );\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isNonNullType } from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // TODO: Spec Section\n\nimport { MaxIntrospectionDepthRule } from './rules/MaxIntrospectionDepthRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * Technically these aren't part of the spec but they are strongly encouraged\n * validation rules.\n */\nexport const recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n  ...recommendedRules,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nconst MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = node.name.value;\n\n      if (visitedFragments[fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n      try {\n        visitedFragments[fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[fragmentName] = undefined;\n      }\n    }\n\n    if (\n      node.kind === Kind.FIELD && // check all introspection lists\n      (node.name.value === 'fields' ||\n        node.name.value === 'interfaces' ||\n        node.name.value === 'possibleTypes' ||\n        node.name.value === 'inputFields')\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      depth++;\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (const child of node.selectionSet.selections) {\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(\n            new GraphQLError('Maximum introspection depth exceeded', {\n              nodes: [node],\n            }),\n          );\n          return false;\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, Kind, ExecutableDefinitionsRule, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, } from 'graphql';\nconst specifiedSDLRules = [\n    LoneSchemaDefinitionRule,\n    UniqueOperationTypesRule,\n    UniqueTypeNamesRule,\n    UniqueEnumValueNamesRule,\n    UniqueFieldDefinitionNamesRule,\n    UniqueDirectiveNamesRule,\n    KnownTypeNamesRule,\n    KnownDirectivesRule,\n    UniqueDirectivesPerLocationRule,\n    PossibleTypeExtensionsRule,\n    UniqueArgumentNamesRule,\n    UniqueInputFieldNamesRule,\n];\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    if (isSchemaDocument) {\n        Array.prototype.push.apply(rules, specifiedSDLRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.includes('Unknown directive') && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map","import { GraphQLError, print, validate, NoDeprecatedCustomRule, parse, } from 'graphql';\nimport { CharacterStream, onlineParser } from '../parser';\nimport { Range, validateWithCustomRules, Position } from '../utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    var _a, _b;\n    let ast = null;\n    let fragments = '';\n    if (externalFragments) {\n        fragments =\n            typeof externalFragments === 'string'\n                ? externalFragments\n                : externalFragments.reduce((acc, node) => acc + print(node) + '\\n\\n', '');\n    }\n    const enhancedQuery = fragments ? `${query}\\n\\n${fragments}` : query;\n    try {\n        ast = parse(enhancedQuery);\n    }\n    catch (error) {\n        if (error instanceof GraphQLError) {\n            const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, enhancedQuery);\n            return [\n                {\n                    severity: DIAGNOSTIC_SEVERITY.Error,\n                    message: error.message,\n                    source: 'GraphQL: Syntax',\n                    range,\n                },\n            ];\n        }\n        throw error;\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = validateWithCustomRules(schema, ast, customRules, isRelayCompatMode).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = validate(schema, ast, [\n        NoDeprecatedCustomRule,\n    ]).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    for (const [i, node] of error.nodes.entries()) {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[i];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    }\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map","import CodeMirror from 'codemirror';\nimport { getDiagnostics } from 'graphql-language-service';\nconst SEVERITY = ['error', 'warning', 'information', 'hint'];\nconst TYPE = {\n    'GraphQL: Validation': 'validation',\n    'GraphQL: Deprecation': 'deprecation',\n    'GraphQL: Syntax': 'syntax',\n};\nCodeMirror.registerHelper('lint', 'graphql', (text, options) => {\n    const { schema, validationRules, externalFragments } = options;\n    const rawResults = getDiagnostics(text, schema, validationRules, undefined, externalFragments);\n    const results = rawResults.map(error => ({\n        message: error.message,\n        severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n        type: error.source ? TYPE[error.source] : undefined,\n        from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n        to: CodeMirror.Pos(error.range.end.line, error.range.end.character),\n    }));\n    return results;\n});\n//# sourceMappingURL=lint.js.map"],"names":["Range","constructor","start","end","this","containsPosition","position","line","character","setStart","Position","setEnd","__name","lessThanOrEqualTo","setLine","setCharacter","LoneSchemaDefinitionRule","context","_ref","_ref2","_oldSchema$astNode","oldSchema","getSchema","alreadyDefined","astNode","getQueryType","getMutationType","getSubscriptionType","schemaDefinitionsCount","SchemaDefinition","node","reportError","GraphQLError","nodes","UniqueOperationTypesRule","schema","definedOperationTypes","Object","create","existingOperationTypes","query","mutation","subscription","checkOperationTypes","SchemaExtension","_node$operationTypes","operationTypesNodes","operationTypes","operationType","operation","alreadyDefinedOperationType","concat","UniqueTypeNamesRule","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","typeName","name","value","getType","UniqueEnumValueNamesRule","existingTypeMap","getTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","UniqueFieldDefinitionNamesRule","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","type","isObjectType","isInterfaceType","isInputObjectType","getFields","UniqueDirectiveNamesRule","knownDirectiveNames","DirectiveDefinition","directiveName","getDirective","isExecutableDefinitionNode","kind","Kind","OPERATION_DEFINITION","FRAGMENT_DEFINITION","isTypeSystemDefinitionNode","SCHEMA_DEFINITION","isTypeDefinitionNode","DIRECTIVE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","isTypeSystemExtensionNode","SCHEMA_EXTENSION","isTypeExtensionNode","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","KnownTypeNamesRule","existingTypesMap","definedTypes","def","getDocument","definitions","typeNames","keys","NamedType","_1","parent","_2","ancestors","_ancestors$","definitionNode","isSDL","standardTypeNames","includes","suggestedTypes","suggestionList","didYouMean","specifiedScalarTypes","introspectionTypes","map","KnownDirectivesRule","locationsMap","definedDirectives","getDirectives","specifiedDirectives","directive","locations","astDefinitions","Directive","_key","_parent","_path","candidateLocation","appliedTo","length","invariant","OperationTypeNode","QUERY","DirectiveLocation","MUTATION","SUBSCRIPTION","getDirectiveLocationForOperation","FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE_DEFINITION","ENUM_VALUE","INPUT_OBJECT","INPUT_VALUE_DEFINITION","parentNode","INPUT_FIELD_DEFINITION","ARGUMENT_DEFINITION","inspect","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","directives","seenDirectives","undefined","PossibleTypeExtensionsRule","ScalarTypeExtension","checkExtension","UnionTypeExtension","defNode","expectedKind","defKindToExtKind","isScalarType","isUnionType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","groupBy","list","keyFn","result","Map","item","key","group","get","set","push","UniqueArgumentNamesRule","Field","checkArgUniqueness","_parentNode$arguments","seenArgs","arguments","arg","argName","argNodes","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","leave","prevKnownNames","pop","ObjectField","ExecutableDefinitionsRule","Document","definition","defName","KnownArgumentNamesOnDirectivesRule","directiveArgs","args","_def$arguments","argsNodes","directiveNode","knownArgs","argNode","suggestions","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","fragmentNameUsed","fragment","getRecursivelyReferencedFragments","fragmentDef","fragName","sortValueNode","valueNode","fieldNode","sort","fieldA","fieldB","naturalCompare","LIST","INT","FLOAT","STRING","BOOLEAN","NULL","VARIABLE","reasonMessage","reason","Array","isArray","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fieldMap2","referencedFragmentNames","getReferencedFieldsAndFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","referencedFragmentName2","referencedFragmentName1","parentFieldsAreMutuallyExclusive","fields1","entries","fields2","field1","field2","conflict","findConflict","parentType1","node1","def1","parentType2","node2","def2","name1","name2","args1","args2","values2","every","arg1","value1","value2","stringifyValue","sameArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","fragmentNames1","getFieldsAndFragmentNames","fragmentNames2","findConflictsBetweenSubSelectionSets","getNamedType","_ref3","_ref4","flat","_ref5","subfieldConflicts","print","isListType","ofType","isNonNullType","isLeafType","parentType","cached","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","fragmentType","typeFromAST","typeCondition","selection","selections","alias","inlineFragmentType","PairSet","_data","a","b","_this$_data$get","key1","key2","ProvidedRequiredArgumentsOnDirectivesRule","_schema$getDirectives","requiredArgsMap","keyMap","filter","isRequiredArgument","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","argNodeMap","Set","argDef","argType","isType","NON_NULL_TYPE","defaultValue","getDirectiveValues","directiveDef","variableValues","_node$directives","find","_node$arguments","coercedValues","argumentNodes","argumentNode","isNull","variableName","hasOwnProperty","coercedValue","valueFromAST","getArgumentValues","obj","prop","prototype","call","collectFieldsImpl","fragments","runtimeType","visitedFragmentNames","shouldIncludeNode","fieldList","doesFragmentConditionMatch","skip","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","isAbstractType","isSubType","isValidValueNode","locationType","getInputType","parseLiteral","typeStr","error","message","originalError","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","nullableLocationType","isTypeSubTypeOf","recommendedRules","freeze","checkDepth","visitedFragments","depth","child","specifiedRules","knownOperationNames","operationName","operationCount","subscriptionType","document","collectFields","size","extraFieldSelections","slice","startsWith","InlineFragment","isCompositeType","VariableDefinition","isInputType","variable","getParentType","getFieldDef","suggestion","usageCount","possibleType","getPossibleTypes","possibleInterface","getInterfaces","_usageCount$possibleI","typeA","typeB","usageCountDiff","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","doTypesOverlap","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","s","operationNode","_operationNode$variab","seenVariableDefinitions","variableDefinitions","variableNodes","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","variableDef","Argument","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","field","isRequiredInputField","isOneOf","_fieldNodeMap$keys$","isNullLiteral","isVariable","validateOneOfInputObject","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","_fieldNode$arguments","providedArgs","argTypeStr","varDefMap","varDef","varTypeStr","SelectionSet","i","j","collectConflictsWithin","findConflictsWithinSelectionSet","reasonMsg","checkArgUniquenessPerField","typeNode","_typeNode$fields","_fieldDef$arguments","parentName","ASTValidationContext","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","Symbol","toStringTag","spreads","setsToVisit","collectedNames","nodesToVisit","spread","ValidationContext","typeInfo","super","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","getVariableUsages","newUsages","TypeInfo","visit","visitWithTypeInfo","Variable","getDefaultValue","getEnumValue","validate","documentAST","rules","options","_options$maxErrors","maxErrors","devAssert","assertValidSchema","abortObj","errors","visitor","visitInParallel","rule","e","NoDeprecatedCustomRule","deprecationReason","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","specifiedSDLRules","validateWithCustomRules","customRules","isRelayCompatMode","isSchemaDocument","apply","DIRECTIVE","SEVERITY$1","DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","externalFragments","_a","_b","reduce","acc","enhancedQuery","parse","range","getRange","column","severity","source","validateQuery","validationErrorAnnotations","flatMap","annotations","deprecationWarningAnnotations","Warning","highlightedNodes","highlightNode","loc","highlightLoc","getLocation","location","queryText","parser","onlineParser","state","startState","lines","split","stream","CharacterStream","eol","token","getStartOfToken","getCurrentPosition","SEVERITY","TYPE","CodeMirror","registerHelper","text","validationRules","from","Pos","to"],"sourceRoot":""}